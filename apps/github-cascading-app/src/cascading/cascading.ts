import { coerce, compare, parse, valid } from 'semver';
import { BaseLogger, CascadingConfiguration, CascadingPullRequestInfo, CheckConclusion } from './interfaces';

/** Footer message of the Pull Request body */
export const MESSAGE_FOOTER = `
This PR has been generated by the [Otter](https://github.com/AmadeusITGroup/otter) cascading tool.`;

/** Message to disable reviewer bypass for this PR specifically */
export const AVOID_REVIEWER_BYPASS = `
- [ ] :no_entry_sign: stop reviewer bypass for this PR`;

/** Content of the message added to the pull request body when requesting to re-evaluate the base branch */
export const MESSAGE_NEW_UPDATE = '- [x] Recreate with update after merging from';

/** prefix of cascading branch */
export const CASCADING_BRANCH_PREFIX = 'cascading';

/** prefix of conflicting cascading branch */
export const CASCADING_CONFLICT_BRANCH_PREFIX = 'conflict';

/**
 * Handles the cascading to the next branch
 */
export abstract class Cascading {
  /**
   * Load configuration
   *
   * @param branchName remote branch name used when no local files available
   */
  protected abstract loadConfiguration(branchName?: string): Promise<CascadingConfiguration>;
  /**
   * Delete a remote branch
   *
   * @param branchName remote branch name
   */
  protected abstract deleteBranch(branchName: string): Promise<void>;
  /**
   * Create a new local branch
   *
   * @param branchName local branch name
   * @param baseBranch
   */
  protected abstract createBranch(branchName: string, baseBranch: string): Promise<void>;
  /**
   * Pull a given remote branch
   *
   * @param branchName remote branch name
   * @param baseBranch
   */
  protected abstract merge(branchName: string, baseBranch: string): Promise<void>;
  /**
   * Get the repository branch list
   */
  protected abstract getBranches(): Promise<string[]>;
  /**
   * Create a pull request
   *
   * @param cascadingBranch name of the cascading branch (pull request head)
   * @param targetBranch name of the targeted branch (pull request base)
   * @param body body of the pull request
   * @param title title of the pull request
   * @param labels list of labels to add to the created PR
   */
  protected abstract createPullRequest(cascadingBranch: string, targetBranch: string, body: string, title: string, labels?: string[]): Promise<void>;
  /**
   * Update the body and title of a pull request
   *
   * @param id pull request ID
   * @param body new pull request body
   * @param title new pull request title
   */
  protected abstract updatePullRequestMessage(id: string | number, body: string, title?: string): Promise<void>;
  /**
   * Get the pull requests corresponding to the given branches
   *
   * @param cascadingBranch head branch of the pull request
   * @param targetBranch base branch of the pull request
   */
  protected abstract getPullRequests(cascadingBranch: string, targetBranch: string): Promise<CascadingPullRequestInfo[]>;
  /**
   * Get the pull request corresponding to the given id
   *
   * @param id pull request number
   */
  protected abstract getPullRequestFromId(id: string | number): Promise<CascadingPullRequestInfo>;
  /**
   * Determine of the pull request is a cascading pull
   *
   * @param id ID of the pull request
   */
  protected abstract isCascadingPullRequest(id: string | number): Promise<boolean>;
  /**
   * Determine of the triggered checks of a pull request are passed
   *
   * @param id ID of the pull request
   * @param conclusion Result of the check suite
   */
  protected abstract areAllChecksPassed(id: string | number, conclusion: CheckConclusion): Promise<boolean>;
  /**
   * Trigger the pull request merge
   *
   * @param id ID of the pull request
   */
  protected abstract mergePullRequest(id: string | number): Promise<boolean>;
  /**
   * Determine if the base branch is ahead of the target branch
   *
   * @param baseBranch
   * @param targetBranch
   */
  protected abstract isBranchAhead(baseBranch: string, targetBranch: string): Promise<boolean>;

  /**
   * @param logger Logger
   * @param username User name used for git commands
   * @param email Email used for git commands
   */
  constructor(public logger: BaseLogger, public username: string = 'Auto Cascading', public email: string = 'cascading@otter.com') {
  }

  /**
   * Retrieve the ordered cascading branches from the repository full branch list
   *
   * @param fullBranchesList full list of branches of the repository
   * @param config Cascading configuration
   */
  protected getOrderedCascadingBranches(fullBranchesList: string[], config: CascadingConfiguration) {
    const cascadingBranchesPattern = new RegExp(config.cascadingBranchesPattern);
    const versionCapturePattern = new RegExp(config.versionCapturePattern);
    const ignoredPatterns = config.ignoredPatterns.map((pattern) => new RegExp(pattern));
    this.logger.debug('Sort the full list of branches:');
    this.logger.debug(JSON.stringify(fullBranchesList, null, 2));
    const branchesToCascade = fullBranchesList
      .filter((branch) => cascadingBranchesPattern.test(branch) || branch === config.defaultBranch)
      .filter((branch) => !ignoredPatterns.some((pattern) => pattern.test(branch)))
      .map((branch) => {
        if (branch === config.defaultBranch) {
          return {
            branch,
            semver: undefined
          };
        } else {
          const version = versionCapturePattern.exec(branch)?.[1];
          if (!version) {
            return {
              branch,
              semver: null
            };
          }
          const parsedVersion = parse(version);
          return {
            branch,
            semver: parsedVersion || parse(valid(coerce(version)))
          };
        }
      })
      .filter(({branch, semver}) => {
        if (semver === null) {
          this.logger.warn(`Failed to parse the branch ${branch}, it will be skipped from cascading`);
          return false;
        }
        return true;
      })
      .sort((branchObjectA, branchObjectB) => {
        if (!branchObjectA.semver) {
          return 1;
        } else if (!branchObjectB.semver) {
          return -1;
        }

        return compare(branchObjectA.semver, branchObjectB.semver);
      });

    this.logger.debug('Discovered following branches to cascade ' + JSON.stringify(branchesToCascade.map(({branch}) => branch), null, 2));
    return branchesToCascade;
  }

  /**
   * Generate teh cascading branch name
   *
   * @param baseVersion Version extracted from the base branch
   * @param targetVersion Version extracted from the target branch
   * @param isConflicting specify if the branch should be flagged as conflicting
   */
  protected determineCascadingBranchName(baseVersion: string, targetVersion: string, isConflicting = false) {
    return `${isConflicting ? CASCADING_CONFLICT_BRANCH_PREFIX : CASCADING_BRANCH_PREFIX}/${baseVersion}-${targetVersion}`;
  }

  /**
   * Determine if the branch is a cascading branch created by the application
   *
   * @param branch Name of the branch to check
   */
  protected isCascadingBranchName(branch: string) {
    if (!branch.startsWith(CASCADING_BRANCH_PREFIX) && !branch.startsWith(CASCADING_CONFLICT_BRANCH_PREFIX)) {
      return false;
    }

    const splitBranchName = branch.split('/');
    return splitBranchName.length === 2;
  }

  /**
   * Find the pull request open with for the given branches
   *
   * @param baseBranch name of the base branch (head of the pull request)
   * @param targetBranch name of the target branch (base of the pull request)
   */
  protected async findOpenPullRequest(baseBranch: string, targetBranch: string) {
    const pRs = await this.getPullRequests(baseBranch, targetBranch);
    const openPr = pRs.find((pr) => pr.isOpen);
    return openPr;
  }

  /**
   * Generate the pull request body part added in case of cascading re-evaluation request
   *
   * @param baseBranch Base branch of the pull request
   * @returns
   */
  protected createMessageNewUpdate(baseBranch: string) {
    return `
---
${MESSAGE_NEW_UPDATE} ${baseBranch}
---`;
  }

  /**
   * Create the Pull Request title
   *
   * @param config
   * @param currentBranch name of the base branch
   * @param targetBranch name of the target branch (base of the pull request)
   */
  protected createPullRequestTitle(config: CascadingConfiguration, currentBranch: string, targetBranch: string) {
    return config.pullRequestTitle
      .replaceAll('$origin', currentBranch)
      .replaceAll('$target', targetBranch);
  }

  /**
   * Add update message to the pull request body to request re-evaluation of the base branch
   *
   * @param cascadingBranch name of the cascading branch (head of the pull request)
   * @param currentBranch name of the base branch
   * @param targetBranch name of the target branch (base of the pull request)
   * @param config
   */
  protected async addTriggerToPullRequest(cascadingBranch: string, currentBranch: string, targetBranch: string, config: CascadingConfiguration) {
    this.logger.debug(`Run trigger to cascading PR from ${cascadingBranch}`);
    const openPr = await this.findOpenPullRequest(cascadingBranch, targetBranch);

    if (!openPr) {
      try {
        await this.deleteBranch(cascadingBranch);
        await this.createBranch(cascadingBranch, currentBranch);
      } catch (error) {
        this.logger.warn(`Failed to renew the cascading branch ${cascadingBranch}`);
        this.logger.debug(JSON.stringify(error, null, 2));
      }
      return this.createPullRequestWithMessage(cascadingBranch, currentBranch, targetBranch, config, true);
    } else {
      let message = openPr.body || '';
      const triggerMessage = this.createMessageNewUpdate(currentBranch);
      const triggerUncheckMessage = triggerMessage.replace('[x]', '[ ]');
      if (message.includes(triggerUncheckMessage)) {
        message.replace(triggerUncheckMessage, triggerMessage);
      } else if (!message.includes(triggerMessage)) {
        const footerIndex = openPr.body?.indexOf(MESSAGE_FOOTER);
        if (footerIndex === undefined || footerIndex < 0) {
          message += this.createMessageNewUpdate(currentBranch) + MESSAGE_FOOTER;
        } else {
          message = message.slice(0, footerIndex) + this.createMessageNewUpdate(currentBranch) + message.slice(footerIndex);
        }
      }

      return this.updatePullRequestMessage(openPr.id, message);
    }
  }

  /**
   * Create a pull request and generate its body and title
   *
   * @param cascadingBranch name of the cascading branch (head of the pull request)
   * @param currentBranch name of the base branch of the cascading process
   * @param targetBranch name of the branch target (base of the pull request)
   * @param config
   * @param shouldAddUpdateMessage Determine if the body of the new pull request should add the update request message
   */
  protected async createPullRequestWithMessage(cascadingBranch: string, currentBranch: string, targetBranch: string, config: CascadingConfiguration, shouldAddUpdateMessage = false) {
    this.logger.debug(`Creating Pull Request ${cascadingBranch} -> ${targetBranch}`);
    const openPr = await this.findOpenPullRequest(cascadingBranch, targetBranch);
    if (openPr) {
      this.logger.warn(`Pull Request ${cascadingBranch} -> ${targetBranch} already exists. Creation will be skipped.`);
      return;
    }
    const title = this.createPullRequestTitle(config, currentBranch, targetBranch);
    let message = `## Cascading from ${currentBranch} to ${targetBranch}`;
    if (config.bypassReviewers) {
      message += AVOID_REVIEWER_BYPASS;
    }
    if (shouldAddUpdateMessage) {
      message += this.createMessageNewUpdate(currentBranch);
    }
    message += MESSAGE_FOOTER;
    await this.createPullRequest(cascadingBranch, targetBranch, message, title, config.labels);
  }

  protected async isAllowingBypassPullRequest(pullRequest: Pick<CascadingPullRequestInfo, 'id'>) {
    const pr = await this.getPullRequestFromId(pullRequest.id);
    return pr.isOpen && !pr.body?.includes(AVOID_REVIEWER_BYPASS.replace('[ ]', '[x]'));
  }

  /**
   * Launch the cascading process
   *
   * @param currentBranchName name of the branch to cascade (ex: release/8.0)
   */
  public async cascade(currentBranchName: string) {
    this.logger.debug(`Run cascading on ${currentBranchName}`);
    const config = await this.loadConfiguration(currentBranchName);

    if (!(new RegExp(config.cascadingBranchesPattern)).test(currentBranchName) && currentBranchName !== config.defaultBranch) {
      this.logger.info(`Skip cascading because the branch "${currentBranchName}" does not match "${config.cascadingBranchesPattern}"`);
      return;
    }

    const isIgnored = config.ignoredPatterns
      .map(((pattern) => new RegExp(pattern)))
      .some((pattern) => pattern.test(currentBranchName));

    if (isIgnored) {
      this.logger.info(`Skip cascading because the branch "${currentBranchName}" is ignored`);
      return;
    }

    this.logger.info('Cascading plugin execution');
    const branches = await this.getBranches();
    const cascadingBranches = this.getOrderedCascadingBranches(branches, config);
    const branchIndex = cascadingBranches.findIndex(({ branch }) => branch === currentBranchName);

    if (branchIndex < 0) {
      this.logger.error(`The branch ${currentBranchName} is not part of the list of cascading branch. The process will stop.`);
      return;
    }

    if (branchIndex === cascadingBranches.length - 1) {
      this.logger.info(`The branch ${currentBranchName} is the last branch of the cascading. The process will stop.`);
      return;
    }

    const currentBranch = cascadingBranches[branchIndex];
    const targetBranch = cascadingBranches[branchIndex + 1];
    const cascadingBranch = this.determineCascadingBranchName(currentBranch.semver?.format() || currentBranch.branch, targetBranch.semver?.format() || targetBranch.branch);
    const isAhead = await this.isBranchAhead(currentBranch.branch, targetBranch.branch);

    if (!isAhead) {
      this.logger.info(`${currentBranch.branch} is not ahead of ${targetBranch.branch}. The cascading process will be skipped`);
      return;
    }

    if (branches.includes(cascadingBranch)) {
      try {
        await this.merge(currentBranch.branch, cascadingBranch);
      } catch {
        this.logger.warn(`Fail to merge ${currentBranch.branch} into ${cascadingBranch}, will retry when merged`);
        await this.addTriggerToPullRequest(cascadingBranch, currentBranch.branch, targetBranch.branch, config);
        return;
      }
    } else {
      try {
        await this.createBranch(cascadingBranch, targetBranch.branch);
        await this.merge(currentBranch.branch, cascadingBranch);
      } catch {
        this.logger.warn(`Fail to merge ${currentBranch.branch} into ${cascadingBranch} before creating the PR, will switch to conflict mode (and create the PR from ${currentBranch.branch})`);
        try {
          await this.deleteBranch(cascadingBranch);
        } catch {
          this.logger.warn(`Fail to remove the cascading branch "${cascadingBranch}"`);
        }
        const conflictCascadingBranch = this.determineCascadingBranchName(currentBranch.semver?.format() || currentBranch.branch, targetBranch.semver?.format() || targetBranch.branch, true);
        await this.createBranch(conflictCascadingBranch, currentBranch.branch);
      }
    }
    await this.createPullRequestWithMessage(cascadingBranch, currentBranch.branch, targetBranch.branch, config);
  }

  /**
   * Determine if the pull request merged requires to re-evaluate the cascading of it's base branch
   * This is happening when the process failed to update the pull request
   *
   * @param pullRequest Pull request merged
   * @returns base branch name
   */
  public async branchToReevaluateCascading(pullRequest: Pick<CascadingPullRequestInfo, 'id' | 'body'>) {
    if (!(await this.isCascadingPullRequest(pullRequest.id))) {
      this.logger.info(`The PR ${pullRequest.id} is not a cascading PR.`);
      return undefined;
    }
    const reevaluateTask = `${MESSAGE_NEW_UPDATE} `;
    const foundIndex = pullRequest.body?.indexOf(reevaluateTask);
    if (foundIndex === undefined || foundIndex < 0) {
      this.logger.info(`The PR ${pullRequest.id} does not request to rerun cascading on original branch`);
      return undefined;
    }

    const endOfMessageIndex = foundIndex + reevaluateTask.length;
    const eolMessageIndex = pullRequest.body!.indexOf('\n', endOfMessageIndex);
    return pullRequest.body!.substring(endOfMessageIndex, eolMessageIndex);
  }

  /**
   * Merge a cascading pull request ignoring reviewers
   *
   * @param pullRequest Pull request to merge
   * @param headBranch cascading branch
   * @param conclusion result of the check suite
   */
  public async mergeCascadingPullRequest(pullRequest: Pick<CascadingPullRequestInfo, 'id'>, headBranch: string, conclusion: CheckConclusion) {
    const config = await this.loadConfiguration(headBranch);
    if (!config.bypassReviewers) {
      this.logger.debug(`Reviewer bypass is disabled on ${headBranch}`);
      return;
    }

    if (!await this.isCascadingPullRequest(pullRequest.id)) {
      this.logger.info(`The PR ${pullRequest.id} is not a cascading PR`);
      return;
    }

    if (!await this.areAllChecksPassed(pullRequest.id, conclusion)) {
      this.logger.warn(`The checks of the PR ${pullRequest.id} are not passed. The merge will be skipped`);
      return;
    }

    if (!await this.isAllowingBypassPullRequest(pullRequest)) {
      this.logger.info(`The PR ${pullRequest.id} is not allowing bypass. The merge will be skipped`);
      return;
    }

    const merged = await this.mergePullRequest(pullRequest.id);
    if (!merged) {
      this.logger.error(`Failed to merge the PR ${pullRequest.id}`);
    }
  }
}

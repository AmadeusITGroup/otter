<% if (projectDescription) { %># <%=projectDescription%><% } %>

### Based on OpenAPI spec 0.0.0

The SDK contains 2 different parts:

* Auto generated code (based on OpenAPI Spec)
* Specific code dedicated to this SDK

## Structure

### Auto Generated code

A main part of the SDK is automatically generated from an OpenAPI Spec.
The following folders contain the generated code:

* **src/api**: Containing the API calls files
* **src/models/base**: Models based of OpenAPI definitions

The Code can be regenerated by running the following command:

```shell
yarn create @ama-sdk typescript --spec-path [path to your openapi file]
```
Note that you can use ```npm exec``` instead of ```yarn``` for every command specified in this documentation.

***

### Where to put my custom code?

There are 2 places where we can add custom code:

* **src/helpers**: should contain the helper functions to transform the data.
* **src/models/custom**: should contain the models specific to this SDK (mainly the helper functions return type).

### How to extend a Model?

You can extend a base model in 3 steps:

* Redirect the default model to your override:

```typescript
// src/models/base/your-model-name/index.ts
export * from "../../core/your-model-name";
```

* Indicate to OpenAPI CodeGen that you have overridden the base model:

```gitignore
# in .openapi-codegen-ignore
src/models/base/your-model-name/index.ts
```

* Create your core models

```typescript
// src/models/core/your-model-name/index.ts
export * from "./your-model-name.ts";
export * from "./your-model-name.reviver.ts";
```

```typescript
// src/models/core/your-model-name/your-model-name.ts
import { YourModelName as BaseYourModelName } from "../../base/your-model-name/your-model-name";

export interface YourModelName extends BaseYourModelName {
  // Additional fields
}
```

```typescript
// src/models/core/your-model-name/your-model-name.reviver.ts
import { yourFunction } from "../../../helpers/your-model-name";
import { reviveYourModelName as baseReviveYourModelName } from "../../base/your-model-name/your-model-name.reviver";
import { YourModelName } from "./your-model-name";

import {Reviver, utils} from "@ama-sdk/core";

export function reviveYourModelName<T extends YourModelName = YourModelName>(data: any, dictionary?: any) {
  // TODO: use BaseRevive<T> when ready
  const revivedData: T | undefined = baseReviveYourModelName(data, dictionary) as T | undefined;

  if (!revivedData) { return ; }

  if (!revivedData.yourField) {
    revivedData.yourField = yourFunction(revivedData);
  }

  return revivedData;
}
```

***

## Commands

Some commands are provided to keep your SDK up-to-date.

### Generate SDK from an OpenAPI specification

```shell
yarn spec:regen
```

### Run Unit Tests

You can build and run UT with:

```shell
yarn test
```

## Manage dates

### The timezone issue
Managing dates with timezones has always been a bit painful in front end applications.
Let's give a concrete example to understand the problem:
An API returns the date and hour of your flight in the timezone of the airport location. In our use case, let's say the departure airport is on GTM+7 : 2023-07-10T00:37:00.000+07:00.
The timezone sent is the one from the airport, here GMT+7. If you just use the Date(), the computer browser will convert this in its own timezone.
For example, if the user is in GMT+2 you will end up displaying the following: 2023-07-09T19:37:00.000+02:00.
This is not what you want. You want the exact date time of the flight at the airport timezone, not the one of your user's computer.
However, there might be cases where you might still need the timezone information.
For example, you want to be able to display that the flight is in X hours.
You will need to compute this information with the two timezones -- the airport's and the user's.

### Solution proposed to remove the timezone: utils.DateTime
The Otter framework has introduced the `utils.Date` and `utils.DateTime` objects to replace the `Date` implementation and convert the date returned by the API as if it were in the
timezone of the user.

Dates can be generated as `utils.Date` or `string` depending on the value of the `stringifyDate` option. This ensures that the timezone will not impact the date. 
In the case of `date-time` objects, the default type used is the native `string` and `Date` type depending on the `stringifyDate` option value.

If you want to generate a date-time using `utils.DateTime`, you can do it at property level thanks to the `x-local-timezone` vendor.

If you need to keep the timezone information, extend the model and create a new field directly in the SDK.
As this field does not exist in the specification, it will not be part of the base model but of the core model instead (the first one being completely generated from the API specifications).

Simple example:
```yaml
  Flight:
    type: "object"
    required:
      - departureDateTime
    properties:
      departureDateTime:
        type: string
        x-local-timezone: true
        description: If this vendor extension is present send dates without their timezone
        format: date-time
```
Base model generated
```typescript
// flight.ts generated in base models
export interface Flight {
  /** @see utils.DateTime */
  departureDateTime: utils.DateTime;
}
```
You need to create a core model to store the timezone information (src/models/core/flight.ts):
```typescript
import type { IgnoreEnum } from '@ama-sdk/core';
import type { Flight } from '../../base/flight/flight';
export type FlightStopCoreIfy<T extends IgnoreEnum<Flight>> = T & {
  /** Departure date time of the flight considering timezone */
  departureDateTimeConsideringTimezone?: Date;
};
```

And an associated reviver (src/models/core/flight.reviver.ts):
```typescript
import type { Flight } from '../../base/flight/flight';
import type { reviveFlight } from '../../base/flight/flight.reviver';
import type { FlightCoreIfy } from './flight';

/**
 * @param baseRevive
 */
export function reviveFlightFactory<R extends typeof reviveFlight>(baseRevive: R) {
  const reviver = <T extends Flight = Flight>(data: any, dictionaries?: any) => {
    const originalData: any = {...data};
    const revivedData = baseRevive<FlightCoreIfy<T>>(data, dictionaries);
    if (!revivedData) {
      return;
    }
    revivedData.departureDateTimeConsideringTimezone = originalData.departureDateTimeConsideringTimezone && new Date(originalData.departureDateTimeConsideringTimezone)
      || originalData.departureDateTime && new Date(originalData.departureDateTime);
    return revivedData;
  };
  return reviver;
}
```

And export it here (src/models/core/flight/index.ts):
```typescript
export * from './flight';
export * from './flight.reviver';
```

And here (src/models/core/index.ts):
```typescript
export * from './flight/index';
```

You can now use departureDateTimeConsideringTimezone to access the timezone information.
See [utils.Date](https://github.com/AmadeusITGroup/otter/blob/main/packages/%40ama-sdk/core/src/fwk/date.ts) for more information.

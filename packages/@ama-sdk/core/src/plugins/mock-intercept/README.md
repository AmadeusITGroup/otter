# Mock intercept plugin

The mock interception statregy works based on two interceptions: request and fetch. For each interception, a plugin has been made.

## Mock intercept request plugin

It's very possible that the UI of the application is in an advanced phase compared to the backend. The API base URL may not be available, or the HTTP method or header included by other plugins may not be accepted yet. For those reasons, it's important to intercept the request before it is sent, without blocking the rest of the application.

The Mock intercept request plugin intercepts the request URL and, at the same time, encodes the request information inside a custom header. You can indicate a filter function that will be used to test if the request should or should not be intercepted.

The mock intercept plugin needs a mock adapter. The adapter is responsible for identifying the operation and by returning mocked data that relates to this operation. The job of the plugin, on the other hand, is to identify that a request has been intercepted, decode the original request and pass this information to the adapter. If you have modified the default interception request (please refer to the `MockInterceptRequest` plugin), you can as well configure the fetch plugin to identify this custom interception (please refer to the plugin constructor options).

Example of usage:

```typescript
const baseConfig = new ApiFetchClient({
    basePath: 'http://my-api.com',
    requestPlugins: [
      new MockInterceptRequest({
        adapter: myAdapter
      })
    ]
});
```

## Mock intercept fetch plugin

The mock mechanism provides, via the `getResponse` function, a way to completely override the fetch response. To apply the mock at FetchAPI level, we provide the `MockInterceptFetch`.
It will work with the `MockInterceptRequest` on the same mock set.

Example of usage:

```typescript
const baseConfig = new ApiFetchClient({
    basePath: 'http://my-api.com',
    requestPlugins: [
      new MockInterceptRequest({
        adapter: myAdapter
      })
    ],
    fetchPlugins: [
      new MockInterceptFetch({
        adapter: myAdapter
      })
    ]
});
```

## MockAdapter

The interception plugin expects to receive a mock adapter that will handle the mock retrieval. This adapter will contain a list of mock responses for each operation and the logic on how to retrieve them (e.g. random retrieval or sequential). The adapter will then return the mock for a given operation. There are currently two adapters implemented, but you can implement your own by simply extending the `BaseMockAdapter` class. The adapters implemented are:

* *RandomMockAdapter*: Randomly retrieves the next mock
* *SequentialMockAdapter*: Sequentially retrieves the next mock

Example of usage:

```typescript
/**
 *
 * SDK's generated by `@ama-sdk/schematics` contain, in the spec folder, an array of `PathObject` generated directly from the its swagger spec
 *
 */
import {OPERATION_ADAPTER} from '@ama-sdk/sdk/spec/operation-adapter';

const myRandomAdapter: new RandomMockAdapter(
  OPERATION_ADAPTER,
  {
    // Mock data for createCart operation
    createCart: [{
      mockData: {} as CartReply
    }]
  }
);

const myRandomAdapter: new SequentialMockAdapter(
  OPERATION_ADAPTER,
  {
    // Mock data for createCart operation
    createCart: [{
      mockData: {} as CartReply
    }]
  }
);

const baseConfig: BaseApiConstructor = {
    basePath: 'http://my-api.com',
    requestPlugins: [
      new MockInterceptRequest({
        adapter: myAdapter
      })
    ]
}
```

### Initializing the mocks via an async operation

If you don't have your mocks right away during the bootstrap and need the result of an async operation, you may pass an initialization function to the constructor that will be called the first time the plugin needs mocks for a request.

Example of usage:

```typescript
/**
 *
 * SDK's generated by `@ama-sdk/schematics` contain, in the spec folder, an array of `PathObject` generated directly from the its swagger spec
 *
*/
import {OPERATION_ADAPTER} from '@ama-sdk/sdk/spec/operation-adapter';

const myAdapter: new RandomMockAdapter(
  OPERATION_ADAPTER,
  () => {
    return fetch('http://my-test-server/getMocks');
  }
);

const baseConfig: BaseApiConstructor = {
    basePath: 'http://my-api.com',
    requestPlugins: [
      new MockInterceptRequest()
    ],
    fetchPlugins: [
      new MockInterceptFetch({
        adapter: myAdapter
      })
    ]
}
```

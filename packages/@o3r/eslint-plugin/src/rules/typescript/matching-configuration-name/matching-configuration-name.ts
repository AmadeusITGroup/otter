import { TSESTree } from '@typescript-eslint/utils';
import { createRule } from '../../utils';

const nameDeterminingFunctionNames = ['computeItemIdentifier', 'computeConfigurationName'];

export default createRule({
  name: 'matching-configuration-name',
  meta: {
    hasSuggestions: true,
    fixable: 'code',
    type: 'problem',
    docs: {
      // eslint-disable-next-line max-len
      description: 'Ensures that the configuration interface name matches the first parameter of `computeItemIdentifier` (or `computeConfigurationName`) used beside the configuration interface to expose its ID (as generated by the configuration module).',
      recommended: 'strict'
    },
    schema: [],
    messages: {
      error: '{{currentValue}} does not match: {{possibleValues}}',
      suggestion: 'Replace {{currentValue}} by {{recommendedValue}}'
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CallExpression: (node) => {
        if (
          node.callee.type !== TSESTree.AST_NODE_TYPES.Identifier
          || !nameDeterminingFunctionNames.includes(node.callee.name)
          || !node.arguments.length
          || node.arguments[0].type !== TSESTree.AST_NODE_TYPES.Literal
          || typeof node.arguments[0].value !== 'string'
        ) {
          return;
        }

        const sourceCode = context.getSourceCode();
        const interfaceNames = sourceCode.ast.body
          .filter((statement): statement is TSESTree.ExportNamedDeclaration & { declaration: TSESTree.TSInterfaceDeclaration } =>
            statement.type === TSESTree.AST_NODE_TYPES.ExportNamedDeclaration
            && statement.declaration?.type === TSESTree.AST_NODE_TYPES.TSInterfaceDeclaration
            && (statement.declaration.extends || []).some((heritageClause) =>
              heritageClause.expression.type === TSESTree.AST_NODE_TYPES.Identifier
              && heritageClause.expression.name === 'Configuration'
            )
          )
          .map((statement) => statement.declaration.id.name);
        const fnArgInterfaceName = node.arguments[0].value;

        if (interfaceNames.length && !interfaceNames.includes(fnArgInterfaceName)) {
          return context.report({
            node: node.arguments[0],
            loc: node.arguments[0].loc,
            messageId: 'error',
            data: {
              currentValue: fnArgInterfaceName,
              possibleValues: interfaceNames.join(', ')
            },
            fix: (fixer) => {
              return fixer.replaceText(node.arguments[0], `'${interfaceNames[0]}'`);
            },
            suggest: interfaceNames.map((interfaceName) => ({
              messageId: 'suggestion',
              data: {
                currentValue: fnArgInterfaceName,
                recommendedValue: interfaceName
              },
              fix: (fixer) => {
                return fixer.replaceText(node.arguments[0], `'${interfaceName}'`);
              }
            }))
          });
        }
      }
    };
  }
});

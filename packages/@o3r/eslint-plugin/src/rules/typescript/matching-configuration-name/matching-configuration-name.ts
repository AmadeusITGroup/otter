import {
  TSESTree
} from '@typescript-eslint/utils';
import {
  createRule
} from '../../utils';

const nameDeterminingFunctionNames = ['computeItemIdentifier', 'computeConfigurationName'];

export default createRule({
  name: 'matching-configuration-name',
  meta: {
    hasSuggestions: true,
    fixable: 'code',
    type: 'problem',
    docs: {
      description: 'Ensures that the configuration interface name matches the first parameter of `computeItemIdentifier`'
      + ' (or `computeConfigurationName`) used beside the configuration interface to expose its ID (as generated by the configuration module).'
    },
    schema: [],
    messages: {
      error: '{{currentValue}} does not match: {{possibleValues}}',
      suggestion: 'Replace {{currentValue}} by {{recommendedValue}}'
    }
  },
  defaultOptions: [],
  create: (context) => {
    const rule = (node: TSESTree.CallExpression) => {
      if (
        node.callee.type !== TSESTree.AST_NODE_TYPES.Identifier
        || !nameDeterminingFunctionNames.includes(node.callee.name)
        || node.arguments.length === 0
        || node.arguments[0].type !== TSESTree.AST_NODE_TYPES.Literal
        || typeof node.arguments[0].value !== 'string'
      ) {
        return;
      }

      const { sourceCode } = context;
      const interfaceNames = sourceCode.ast.body
        .filter((statement): statement is TSESTree.ExportNamedDeclaration & { declaration: TSESTree.TSInterfaceDeclaration } =>
          statement.type === TSESTree.AST_NODE_TYPES.ExportNamedDeclaration
          && statement.declaration?.type === TSESTree.AST_NODE_TYPES.TSInterfaceDeclaration
          && (statement.declaration.extends || []).some((heritageClause) =>
            heritageClause.expression.type === TSESTree.AST_NODE_TYPES.Identifier
            && heritageClause.expression.name === 'Configuration'
          )
        )
        .map((statement) => statement.declaration.id.name);
      const fnArgInterfaceName = node.arguments[0].value;

      if (interfaceNames.length > 0 && !interfaceNames.includes(fnArgInterfaceName)) {
        return context.report({
          node: node.arguments[0],
          loc: node.arguments[0].loc,
          messageId: 'error',
          data: {
            currentValue: fnArgInterfaceName,
            possibleValues: interfaceNames.join(', ')
          },
          fix: (fixer) => {
            return fixer.replaceText(node.arguments[0], `'${interfaceNames[0]}'`);
          },
          suggest: interfaceNames.map((interfaceName) => ({
            messageId: 'suggestion',
            data: {
              currentValue: fnArgInterfaceName,
              recommendedValue: interfaceName
            },
            fix: (fixer) => {
              return fixer.replaceText(node.arguments[0], `'${interfaceName}'`);
            }
          }))
        });
      }
    };

    return {
      CallExpression: rule
    };
  }
});

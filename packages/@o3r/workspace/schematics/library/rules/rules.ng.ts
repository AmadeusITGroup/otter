import {
  readFileSync,
} from 'node:fs';
import * as path from 'node:path';
import {
  apply,
  chain,
  externalSchematic,
  MergeStrategy,
  mergeWith,
  move,
  renameTemplateFiles,
  Rule,
  template,
  url,
} from '@angular-devkit/schematics';
import type {
  Tree,
} from '@angular-devkit/schematics';
import {
  findConfigFileRelativePath,
} from '@o3r/schematics';
import type {
  PackageJson,
  TsConfigJson,
} from 'type-fest';
import {
  updateProjectTsConfig,
} from '../../rule-factories/index';
import type {
  NgGenerateModuleSchema,
} from '../schema';
import {
  updateNgPackagrFactory,
  updatePackageDependenciesFactory,
} from './shared';

/**
 * Set jest files and script in the generated library.
 * @param options
 */
function setUpAngularTestPackageJson(options: NgGenerateModuleSchema & { targetPath: string }): Rule {
  return (tree: Tree) => {
    const packageJsonPath = path.join(options.targetPath, 'package.json');
    const packageJsonContent = tree.readJson(packageJsonPath) as PackageJson;
    packageJsonContent.scripts ||= {};
    packageJsonContent.scripts.test ||= `ng test ${options.name}`;
    tree.overwrite(packageJsonPath, JSON.stringify(packageJsonContent, null, 2));
    return tree;
  };
}

/**
 * Set jest files and script in the generated library.
 * @param options
 */
function setUpJestForAngularJson(options: NgGenerateModuleSchema & { targetPath: string }) {
  return (tree: Tree) => {
    const angularFile = tree.readJson('/angular.json') as { projects: any };
    const project: any = angularFile.projects[options.name];
    project.architect ||= {};
    project.architect.test = {
      builder: '@angular-builders/jest:run',
      options: {
        tsConfig: `tsconfig.spec.json`,
        configPath: `jest.config.js`,
        setupFilesAfterEnv: './testing/setup-jest.ts'
      }
    };

    tree.overwrite('/angular.json', JSON.stringify(angularFile, null, 2));
    return tree;
  };
}

/**
 * generate the rules to adapt the library generated by ng cli
 * @param options Schematic options
 * @param options.targetPath Path where the library has been generated
 */
export function ngGenerateModule(options: NgGenerateModuleSchema & { targetPath: string; packageJsonName: string }): Rule {
  const relativeTargetPath = options.targetPath.replace(/^\//, '');

  /**
   * Update Ng templates
   * @param tree File tree
   * @param context Context of the schematics
   */
  const updateNgTemplate: Rule = (tree, context) => {
    const o3rCorePackageJsonPath = path.resolve(__dirname, '..', '..', '..', 'package.json');
    const o3rCorePackageJson: PackageJson & { generatorDependencies?: Record<string, string> } = JSON.parse(readFileSync(o3rCorePackageJsonPath).toString());
    const otterVersion = o3rCorePackageJson.dependencies!['@o3r/schematics'];

    const templateNg = apply(url('./templates/ng/common'), [
      template({
        ...options,
        tsconfigBasePath: findConfigFileRelativePath(tree, ['tsconfig.base.json', 'tsconfig.json'], options.targetPath),
        tsconfigBuildPath: findConfigFileRelativePath(tree, ['tsconfig.build.json', 'tsconfig.base.json', 'tsconfig.json'], options.targetPath)
      }),
      renameTemplateFiles(),
      move(options.targetPath)
    ]);
    const templateCommonJest = apply(url('./templates/jest'), [
      template({
        ...options,
        tsconfigBasePath: findConfigFileRelativePath(tree, ['tsconfig.base.json', 'tsconfig.json'], options.targetPath)
      }),
      renameTemplateFiles(),
      move(options.targetPath)
    ]);
    const templateNgJest = apply(url('./templates/ng/jest'), [
      template({
        ...options,
        tsconfigSpecPath: findConfigFileRelativePath(tree,
          ['tsconfig.test.json', 'tsconfig.spec.json', 'tsconfig.jest.json', 'tsconfig.jasmine.json', 'tsconfig.base.json', 'tsconfig.json'], options.targetPath),
        tsconfigBasePath: findConfigFileRelativePath(tree, ['tsconfig.base.json', 'tsconfig.json'], options.targetPath)
      }),
      renameTemplateFiles(),
      move(options.targetPath)
    ]);
    const packageJsonContent = tree.readText('/package.json');
    const hasJestInstalled = options.testingFramework === 'jest' || packageJsonContent.match('"jest"');
    return chain([
      mergeWith(templateNg, MergeStrategy.Overwrite),
      ...hasJestInstalled
        ? [
          mergeWith(templateCommonJest, MergeStrategy.Overwrite),
          mergeWith(templateNgJest, MergeStrategy.Overwrite),
          setUpJestForAngularJson(options),
          setUpAngularTestPackageJson({ ...options })
        ]
        : [
          setUpAngularTestPackageJson(options)
        ],
      updatePackageDependenciesFactory(options.targetPath, otterVersion!, o3rCorePackageJson,
        { ...options, useJest: !!hasJestInstalled }
      ),
      updateNgPackagrFactory(options.targetPath),
      (t) => {
        const genPackageJsonPath = path.posix.join(options.targetPath, 'package.json');
        const packageJson = t.readJson(genPackageJsonPath) as PackageJson;
        packageJson.name = options.packageJsonName;
        packageJson.scripts ||= {};
        packageJson.scripts.ng = 'ng';
        t.overwrite(genPackageJsonPath, JSON.stringify(packageJson, null, 2));
        return t;
      }
    ])(tree, context);
  };

  /**
   * Update the root tsconfig files mappings
   * @param tree File tree
   * @param context Context of the schematics
   */
  const updateTsConfigFiles: Rule = (tree, context) => {
    const tsconfigBase = findConfigFileRelativePath(tree, ['tsconfig.base.json', 'tsconfig.json'], '/');
    let tsconfigBuild = findConfigFileRelativePath(tree, ['tsconfig.build.json'], '/');

    if (!tsconfigBase) {
      context.logger.error('No TSConfig found in the workspace to register the library.');
      return;
    }

    // create tsconfig.build.json if it does not exist
    if (!tsconfigBuild || !tree.exists(tsconfigBuild)) {
      const content = {
        extends: tsconfigBase.replace(/^\/?/, './'),
        compilerOptions: {
          declarationMap: false
        },
        angularCompilerOptions: {
          compilationMode: 'partial'
        }
      };
      tsconfigBuild ||= 'tsconfig.build.json';
      tree.create(tsconfigBuild, JSON.stringify(content, null, 2));
    }

    [tsconfigBase, tsconfigBuild].forEach((tsconfigPath) => {
      const configFile = tree.readJson(tsconfigPath) as TsConfigJson;
      configFile.compilerOptions ||= {};
      configFile.compilerOptions.paths ||= {};
      configFile.compilerOptions.baseUrl ||= '.';
      configFile.compilerOptions.paths = Object.fromEntries(
        Object.entries(configFile.compilerOptions.paths).filter(([pathName, _]) => pathName !== options.name));
      configFile.compilerOptions.paths[options.packageJsonName] = [
        path.posix.join(relativeTargetPath, 'src', 'public-api')
      ];
      tree.overwrite(tsconfigPath, JSON.stringify(configFile, null, 2));
    });

    if (tsconfigBuild && tree.exists(tsconfigBuild)) {
      const configFile = tree.readJson(tsconfigBuild) as TsConfigJson;
      configFile.compilerOptions!.paths![options.packageJsonName].unshift(path.posix.join(relativeTargetPath, 'dist'));
      tree.overwrite(tsconfigBuild, JSON.stringify(configFile, null, 2));
    }
  };

  const ngCliUpdate: Rule = (tree, context) => {
    return chain([
      (t, c) => externalSchematic('@schematics/angular', 'library', {
        name: options.name,
        projectRoot: relativeTargetPath,
        prefix: options.prefix
      })(t, c),
      updateNgTemplate,
      updateProjectTsConfig(options.targetPath, 'tsconfig.lib.json', { updateInputFiles: true }),
      updateTsConfigFiles
    ])(tree, context);
  };

  return ngCliUpdate;
}
